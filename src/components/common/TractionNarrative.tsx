import { useRef, useEffect } from 'react'
import { useGSAP } from '@gsap/react'
import gsap from 'gsap'
import { ScrollTrigger } from 'gsap/ScrollTrigger'
import { Factory, Users, ScanLine, CloudRain, Recycle, FileCheck, LucideIcon } from 'lucide-react'

gsap.registerPlugin(ScrollTrigger)

interface MetricDef {
    icon: LucideIcon
    index: string
    number: string
    suffix: string
    label: string
    desc: string
}

const metrics: MetricDef[] = [
    { icon: Factory, index: '01', number: '6', suffix: '', label: 'Industries Covered', desc: 'Automotive, HVAC, Steel, Plastic, Aluminium & Battery — all within one unified platform.' },
    { icon: Users, index: '02', number: '25', suffix: '', label: 'Stakeholders Onboarded', desc: 'Active organizations operating across the global value chain, all connected in real time.' },
    { icon: ScanLine, index: '03', number: '1,20,000', suffix: ' Tons', label: 'Tracking & Traceability', desc: 'Tonnes of material tracked end-to-end with full provenance and timestamped audit trails.' },
    { icon: CloudRain, index: '04', number: '3,56,760', suffix: ' Tons', label: 'Verified Emissions', desc: 'Tonnes of GHG measured, validated, and verified by our precision carbon intelligence layer.' },
    { icon: Recycle, index: '05', number: '73', suffix: '%', label: 'Circularity Index', desc: 'Average circularity score across tracked material flows, above industry median by 2.3×.' },
    { icon: FileCheck, index: '06', number: '15,000', suffix: '+', label: 'Automated Compliance', desc: 'Regulatory reports auto-generated by AI for CBAM, EPR, IRA and global ESG frameworks.' },
]

const topMetrics = metrics.slice(0, 3)
const bottomMetrics = metrics.slice(3, 6)

/* ─── Card: fills exactly 1/3 of the viewport ─────────────── */
const MetricNode = ({ metric }: { metric: MetricDef }) => {
    const Icon = metric.icon
    return (
        <div
            className="feature-card w-[350px] shrink-0 flex flex-col justify-between py-8 px-8 border-l border-data-navy/5 group hover:bg-neutral-50/80 transition-colors duration-500 relative"
        >
            <div className="absolute left-0 top-0 w-[3px] h-full bg-electric-sulfur scale-y-0 group-hover:scale-y-100 transition-transform duration-500 origin-top" />
            <div>
                <span className="text-[2rem] font-black text-electric-sulfur/50 leading-none block mb-2 tracking-tighter select-none pointer-events-none">{metric.index}</span>
                <div className="w-10 h-10 rounded-full bg-data-navy/5 flex items-center justify-center mb-5 group-hover:bg-electric-sulfur group-hover:text-data-navy transition-colors duration-500">
                    <Icon className="w-5 h-5 stroke-[1.5]" />
                </div>
                <p className="text-[2.4rem] font-black tracking-tighter text-electric-sulfur leading-none mb-1">
                    {metric.number}<span className="text-xl">{metric.suffix}</span>
                </p>
                <h3 className="text-[11px] font-black uppercase tracking-tighter leading-tight mb-3 group-hover:translate-x-1 transition-transform duration-500">{metric.label}</h3>
                <p className="text-[10px] font-mono uppercase leading-relaxed opacity-40 group-hover:opacity-70 transition-opacity duration-500 max-w-[280px]">{metric.desc}</p>
            </div>
        </div>
    )
}

/* ─── Animated dot-grid canvas accent ─────────────────────── */
const DotGridAccent = () => {
    const canvasRef = useRef<HTMLCanvasElement>(null)
    useEffect(() => {
        const canvas = canvasRef.current
        if (!canvas) return
        const ctx = canvas.getContext('2d')!
        const W = canvas.offsetWidth; const H = canvas.offsetHeight
        canvas.width = W; canvas.height = H
        const cols = 12, rows = 6
        const padX = W / (cols + 1), padY = H / (rows + 1)
        let frame = 0; let raf: number
        const animate = () => {
            ctx.clearRect(0, 0, W, H)
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const phase = (r * cols + c) + frame * 0.04
                    const alpha = 0.15 + 0.4 * ((Math.sin(phase) + 1) / 2)
                    const radius = 2 + 1.5 * ((Math.sin(phase * 0.7) + 1) / 2)
                    ctx.beginPath(); ctx.arc((c + 1) * padX, (r + 1) * padY, radius, 0, Math.PI * 2)
                    ctx.fillStyle = `rgba(150,204,57,${alpha})`; ctx.fill()
                }
            }
            frame++; raf = requestAnimationFrame(animate)
        }
        animate()
        return () => cancelAnimationFrame(raf)
    }, [])
    return <canvas ref={canvasRef} className="absolute inset-0 w-full h-full opacity-60" />
}

/* ─── Main component ──────────────────────────────────────── */
export const TractionNarrative = () => {
    const sectionRef = useRef<HTMLDivElement>(null)
    const contentWrapperRef = useRef<HTMLDivElement>(null)
    const topTrackRef = useRef<HTMLDivElement>(null)
    const bottomTrackRef = useRef<HTMLDivElement>(null)

    useGSAP(() => {
        if (!topTrackRef.current || !bottomTrackRef.current || !contentWrapperRef.current || !sectionRef.current) return

        const getTrackWidth = () => topTrackRef.current!.scrollWidth
        const getWindowWidth = () => window.innerWidth

        // Cards start off-screen right; rest is immediately visible
        gsap.set([topTrackRef.current, bottomTrackRef.current], { x: () => getWindowWidth() })

        const tl = gsap.timeline({
            scrollTrigger: {
                trigger: sectionRef.current,
                pin: true,
                scrub: 1,
                invalidateOnRefresh: true,
                start: 'top top',
                end: () => `+=${getTrackWidth() + getWindowWidth()}`,
            }
        })

        // Phase 1: cards scroll in from right
        tl.to([topTrackRef.current, bottomTrackRef.current], {
            x: () => getWindowWidth() - getTrackWidth(),
            ease: 'none',
            duration: () => getTrackWidth(),
        })
        // Phase 2: whole wrapper slides out left
        tl.to(contentWrapperRef.current, {
            x: () => -getWindowWidth(),
            ease: 'none',
            duration: () => getWindowWidth(),
        })

    }, { scope: sectionRef })

    return (
        <section ref={sectionRef} id="traction" className="relative w-full overflow-hidden z-[50] h-screen bg-white flex flex-col">
            <div ref={contentWrapperRef} className="relative w-full h-full flex flex-col justify-between flex-1 pt-28 pb-8">

                {/* Top row: 3 cards × 100vw/3 = full screen width */}
                <div ref={topTrackRef} className="flex items-stretch gap-0 w-max relative z-10 shrink-0 border-y border-data-navy/5 h-[30vh] max-h-[280px]">
                    {topMetrics.map(m => <MetricNode key={m.label} metric={m} />)}
                </div>

                {/* Central text with dot-grid accent */}
                <div className="relative flex-1 flex flex-col justify-center px-10 md:px-20 pointer-events-none z-0 overflow-hidden">
                    <DotGridAccent />
                    <div className="relative pointer-events-auto z-10">
                        <span className="text-electric-sulfur text-[11px] font-mono uppercase tracking-[0.4em] font-bold block mb-4">Live Telemetry</span>
                        <h2 className="text-[7vw] md:text-[5vw] font-black uppercase tracking-tighter leading-[0.85] text-data-navy max-w-3xl mb-4">
                            Real Time<br />Numbers.
                        </h2>
                        <p className="text-[11px] font-mono uppercase tracking-wider opacity-40 leading-loose max-w-lg">
                            Scroll to explore all 6 live metrics →
                        </p>
                        <div style={{ fontFamily: 'Inter, sans-serif' }} className="absolute top-1/2 right-0 -translate-y-1/2 text-[18vw] font-black text-electric-sulfur leading-none pointer-events-none select-none tracking-tighter">
                            6
                        </div>
                    </div>
                </div>

                {/* Bottom row */}
                <div ref={bottomTrackRef} className="flex items-stretch gap-0 w-max relative z-10 shrink-0 border-y border-data-navy/5 h-[30vh] max-h-[280px]">
                    {bottomMetrics.map(m => <MetricNode key={m.label} metric={m} />)}
                </div>

            </div>
        </section>
    )
}
